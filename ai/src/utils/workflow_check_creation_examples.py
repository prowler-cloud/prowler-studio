# Description: This file contains useful examples of how a check is created taking as reference some possible user queries related to cloud security.
EXAMPLE_CHECK_CREATION_WORKFLOW = {
    # AWS
    "make a check to ensure that the S3 bucket is not public.": {
        "security_analysis": "The requested prompt is related to cloud security, specifically with AWS because S3 is an AWS service for storage. This is a common security best practice to avoid unauthorized access to the bucket content.\nTo do this check you must verify at 4 levels: - Account level: verify that 'Block Public Access' is enabled for the account settings. - Bucket access permissions: verify each bucket has 'Block public access through ACLs' and 'Block public access through bucket policies' enabled. - Access control list (ACL): verify that the bucket does not have an ACL with 'AllUsers' or 'Authenticated Users' with 'List' or 'Write' permissions. - Bucket policy: verify that the bucket does not have a bucket policy that allows public access.",
        "prowler_provider": "aws",
        "service": "s3",
        "check_name": "s3_bucket_not_public_accesible",
        "check_metadata": r"{\n  'Provider': 'aws',\n  'CheckID': 's3_bucket_not_public_accesible',\n  'CheckTitle': 'Ensure there are no S3 buckets open to Everyone or Any AWS user.',\n  'CheckType': [\n\t'Data Protection'\n  ],\n  'ServiceName': 's3',\n  'SubServiceName': '',\n  'ResourceIdTemplate': 'arn:partition:s3:::bucket_name',\n  'Severity': 'critical',\n  'ResourceType': 'AwsS3Bucket',\n  'Description': 'Ensure there are no S3 buckets open to Everyone or Any AWS user.',\n  'Risk': 'Even if you enable all possible bucket ACL options available in the Amazon S3 console the ACL alone does not allow everyone to download objects from your bucket. Depending on which option you select any user could perform some actions.',\n  'RelatedUrl': '',\n  'Remediation': {\n\t'Code': {\n\t  'CLI': 'aws s3api put-public-access-block --public-access-block-configuration BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true --bucket <bucket_name>',\n\t  'NativeIaC': '',\n\t  'Other': '',\n\t  'Terraform': ''\n\t}\n  },\n  'Categories': [\n\t'internet-exposed'\n  ],\n  'DependsOn': [],\n  'RelatedTo': [],\n  'Notes': ''\n}",
        "base_case_scenarios": [
            "- Scenario 1: There are no buckets in the audited account. It should not return any finding.",
            "- Scenario 2: The bucket access is blocked at account level. It should return a finding with a PASS as status.",
            "- Scenario 3: The bucket access is blocked at bucket level. It should return a finding with a PASS as status.",
            "- Scenario 4: The bucket is public. It should return a finding with a FAIL as status.",
        ],
        "check_tests": "from unittest import mock\n\nfrom boto3 import client\nfrom moto import mock_aws\n\nfrom tests.providers.aws.utils import (\n\tAWS_ACCOUNT_NUMBER,\n\tAWS_REGION_US_EAST_1,\n\tset_mocked_aws_provider,\n)\n\n\nclass Test_s3_bucket_not_public_accesible:\n\t@mock_aws\n\tdef test_no_buckets(self):\n\t\tfrom prowler.providers.aws.services.s3.s3_service import S3, S3Control\n\n\t\taws_provider = set_mocked_aws_provider([AWS_REGION_US_EAST_1])\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=aws_provider,\n\t\t):\n\t\t\twith mock.patch(\n\t\t\t\t'prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible.s3_client',\n\t\t\t\tnew=S3(aws_provider),\n\t\t\t):\n\t\t\t\twith mock.patch(\n\t\t\t\t\t'prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible.s3control_client',\n\t\t\t\t\tnew=S3Control(aws_provider),\n\t\t\t\t):\n\t\t\t\t\t# Test Check\n\t\t\t\t\tfrom prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible import (\n\t\t\t\t\t\ts3_bucket_not_public_accesible,\n\t\t\t\t\t)\n\n\t\t\t\t\tcheck = s3_bucket_not_public_accesible()\n\t\t\t\t\tresult = check.execute()\n\n\t\t\t\t\tassert len(result) == 0\n\n\t@mock_aws\n\tdef test_bucket_account_public_block(self):\n\t\ts3_client = client('s3', region_name=AWS_REGION_US_EAST_1)\n\t\tbucket_name_us = 'bucket_test_us'\n\t\ts3_client.create_bucket(Bucket=bucket_name_us)\n\t\t# Generate S3Control Client\n\t\ts3control_client = client('s3control', region_name=AWS_REGION_US_EAST_1)\n\t\ts3control_client.put_public_access_block(\n\t\t\tAccountId=AWS_ACCOUNT_NUMBER,\n\t\t\tPublicAccessBlockConfiguration={\n\t\t\t\t'BlockPublicAcls': True,\n\t\t\t\t'IgnorePublicAcls': True,\n\t\t\t\t'BlockPublicPolicy': True,\n\t\t\t\t'RestrictPublicBuckets': True,\n\t\t\t},\n\t\t)\n\t\tfrom prowler.providers.aws.services.s3.s3_service import S3, S3Control\n\n\t\taws_provider = set_mocked_aws_provider([AWS_REGION_US_EAST_1])\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=aws_provider,\n\t\t):\n\t\t\twith mock.patch(\n\t\t\t\t'prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible.s3_client',\n\t\t\t\tnew=S3(aws_provider),\n\t\t\t):\n\t\t\t\twith mock.patch(\n\t\t\t\t\t'prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible.s3control_client',\n\t\t\t\t\tnew=S3Control(aws_provider),\n\t\t\t\t):\n\t\t\t\t\t# Test Check\n\t\t\t\t\tfrom prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible import (\n\t\t\t\t\t\ts3_bucket_not_public_accesible,\n\t\t\t\t\t)\n\n\t\t\t\t\tcheck = s3_bucket_not_public_accesible()\n\t\t\t\t\tresult = check.execute()\n\n\t\t\t\t\tassert len(result) == 1\n\t\t\t\t\tassert result[0].status == 'PASS'\n\t\t\t\t\tassert (\n\t\t\t\t\t\tresult[0].status_extended\n\t\t\t\t\t\t== 'All S3 public access blocked at account level.'\n\t\t\t\t\t)\n\t\t\t\t\tassert result[0].resource_id == AWS_ACCOUNT_NUMBER\n\t\t\t\t\tassert (\n\t\t\t\t\t\tresult[0].resource_arn\n\t\t\t\t\t\t== f'arn:aws:s3:{AWS_REGION_US_EAST_1}:{AWS_ACCOUNT_NUMBER}:account'\n\t\t\t\t\t)\n\t\t\t\t\tassert result[0].region == AWS_REGION_US_EAST_1\n\n\t@mock_aws\n\tdef test_bucket_public_block(self):\n\t\ts3_client = client('s3', region_name=AWS_REGION_US_EAST_1)\n\t\tbucket_name_us = 'bucket_test_us'\n\t\ts3_client.create_bucket(Bucket=bucket_name_us)\n\t\t# Generate S3Control Client\n\t\ts3control_client = client('s3control', region_name=AWS_REGION_US_EAST_1)\n\t\ts3control_client.put_public_access_block(\n\t\t\tAccountId=AWS_ACCOUNT_NUMBER,\n\t\t\tPublicAccessBlockConfiguration={\n\t\t\t\t'BlockPublicAcls': False,\n\t\t\t\t'IgnorePublicAcls': False,\n\t\t\t\t'BlockPublicPolicy': False,\n\t\t\t\t'RestrictPublicBuckets': False,\n\t\t\t},\n\t\t)\n\t\ts3_client.put_public_access_block(\n\t\t\tBucket=bucket_name_us,\n\t\t\tPublicAccessBlockConfiguration={\n\t\t\t\t'BlockPublicAcls': True,\n\t\t\t\t'IgnorePublicAcls': True,\n\t\t\t\t'BlockPublicPolicy': True,\n\t\t\t\t'RestrictPublicBuckets': True,\n\t\t\t},\n\t\t)\n\t\tfrom prowler.providers.aws.services.s3.s3_service import S3, S3Control\n\n\t\taws_provider = set_mocked_aws_provider([AWS_REGION_US_EAST_1])\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=aws_provider,\n\t\t):\n\t\t\twith mock.patch(\n\t\t\t\t'prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible.s3_client',\n\t\t\t\tnew=S3(aws_provider),\n\t\t\t):\n\t\t\t\twith mock.patch(\n\t\t\t\t\t'prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible.s3control_client',\n\t\t\t\t\tnew=S3Control(aws_provider),\n\t\t\t\t):\n\t\t\t\t\t# Test Check\n\t\t\t\t\tfrom prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible import (\n\t\t\t\t\t\ts3_bucket_not_public_accesible,\n\t\t\t\t\t)\n\n\t\t\t\t\tcheck = s3_bucket_not_public_accesible()\n\t\t\t\t\tresult = check.execute()\n\n\t\t\t\t\tassert len(result) == 1\n\t\t\t\t\tassert result[0].status == 'PASS'\n\t\t\t\t\tassert (\n\t\t\t\t\t\tresult[0].status_extended\n\t\t\t\t\t\t== f'S3 Bucket {bucket_name_us} is not public.'\n\t\t\t\t\t)\n\t\t\t\t\tassert result[0].resource_id == bucket_name_us\n\t\t\t\t\tassert (\n\t\t\t\t\t\tresult[0].resource_arn\n\t\t\t\t\t\t== f'arn:{aws_provider.identity.partition}:s3:::{bucket_name_us}'\n\t\t\t\t\t)\n\t\t\t\t\tassert result[0].region == AWS_REGION_US_EAST_1\n\n\t@mock_aws\n\tdef test_bucket_public_ACL(self):\n\t\ts3_client = client('s3', region_name=AWS_REGION_US_EAST_1)\n\t\tbucket_name_us = 'bucket_test_us'\n\t\ts3_client.create_bucket(Bucket=bucket_name_us)\n\t\tbucket_owner = s3_client.get_bucket_acl(Bucket=bucket_name_us)['Owner']\n\t\t# Generate S3Control Client\n\t\ts3control_client = client('s3control', region_name=AWS_REGION_US_EAST_1)\n\t\ts3control_client.put_public_access_block(\n\t\t\tAccountId=AWS_ACCOUNT_NUMBER,\n\t\t\tPublicAccessBlockConfiguration={\n\t\t\t\t'BlockPublicAcls': False,\n\t\t\t\t'IgnorePublicAcls': False,\n\t\t\t\t'BlockPublicPolicy': False,\n\t\t\t\t'RestrictPublicBuckets': False,\n\t\t\t},\n\t\t)\n\t\ts3_client.put_public_access_block(\n\t\t\tBucket=bucket_name_us,\n\t\t\tPublicAccessBlockConfiguration={\n\t\t\t\t'BlockPublicAcls': False,\n\t\t\t\t'IgnorePublicAcls': False,\n\t\t\t\t'BlockPublicPolicy': False,\n\t\t\t\t'RestrictPublicBuckets': False,\n\t\t\t},\n\t\t)\n\t\ts3_client.put_bucket_acl(\n\t\t\tBucket=bucket_name_us,\n\t\t\tAccessControlPolicy={\n\t\t\t\t'Grants': [\n\t\t\t\t\t{\n\t\t\t\t\t\t'Grantee': {\n\t\t\t\t\t\t\t'URI': 'http://acs.amazonaws.com/groups/global/AllUsers',\n\t\t\t\t\t\t\t'Type': 'Group',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'Permission': 'READ',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t'Owner': bucket_owner,\n\t\t\t},\n\t\t)\n\t\tfrom prowler.providers.aws.services.s3.s3_service import S3, S3Control\n\n\t\taws_provider = set_mocked_aws_provider([AWS_REGION_US_EAST_1])\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=aws_provider,\n\t\t):\n\t\t\twith mock.patch(\n\t\t\t\t'prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible.s3_client',\n\t\t\t\tnew=S3(aws_provider),\n\t\t\t):\n\t\t\t\twith mock.patch(\n\t\t\t\t\t'prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible.s3control_client',\n\t\t\t\t\tnew=S3Control(aws_provider),\n\t\t\t\t):\n\t\t\t\t\t# Test Check\n\t\t\t\t\tfrom prowler.providers.aws.services.s3.s3_bucket_not_public_accesible.s3_bucket_not_public_accesible import (\n\t\t\t\t\t\ts3_bucket_not_public_accesible,\n\t\t\t\t\t)\n\n\t\t\t\t\tcheck = s3_bucket_not_public_accesible()\n\t\t\t\t\tresult = check.execute()\n\n\t\t\t\t\tassert len(result) == 1\n\t\t\t\t\tassert result[0].status == 'FAIL'\n\t\t\t\t\tassert (\n\t\t\t\t\t\tresult[0].status_extended\n\t\t\t\t\t\t== f'S3 Bucket {bucket_name_us} has public access due to bucket ACL.'\n\t\t\t\t\t)\n\t\t\t\t\tassert result[0].resource_id == bucket_name_us\n\t\t\t\t\tassert (\n\t\t\t\t\t\tresult[0].resource_arn\n\t\t\t\t\t\t== f'arn:{aws_provider.identity.partition}:s3:::{bucket_name_us}'\n\t\t\t\t\t)\n\t\t\t\t\tassert result[0].region == AWS_REGION_US_EAST_1",
        "check_code": "from prowler.lib.check.models import Check, Check_Report_AWS\nfrom prowler.providers.aws.services.iam.lib.policy import is_policy_public\nfrom prowler.providers.aws.services.s3.s3_client import s3_client\nfrom prowler.providers.aws.services.s3.s3control_client import s3control_client\n\n\nclass s3_bucket_not_public_accesible(Check):\n\tdef execute(self):\n\t\tfindings = []\n\t\t# 1. Check if public buckets are restricted at account level\n\t\tif (\n\t\t\ts3control_client.account_public_access_block\n\t\t\tand s3control_client.account_public_access_block.ignore_public_acls\n\t\t\tand s3control_client.account_public_access_block.restrict_public_buckets\n\t\t):\n\t\t\treport = Check_Report_AWS(self.metadata())\n\t\t\treport.status = 'PASS'\n\t\t\treport.status_extended = 'All S3 public access blocked at account level.'\n\t\t\treport.region = s3control_client.region\n\t\t\treport.resource_id = s3_client.audited_account\n\t\t\treport.resource_arn = s3_client.account_arn_template\n\t\t\tfindings.append(report)\n\t\telse:\n\t\t\t# 2. If public access is not blocked at account level, check it at each bucket level\n\t\t\tfor arn, bucket in s3_client.buckets.items():\n\t\t\t\tif bucket.public_access_block:\n\t\t\t\t\treport = Check_Report_AWS(self.metadata())\n\t\t\t\t\treport.region = bucket.region\n\t\t\t\t\treport.resource_id = bucket.name\n\t\t\t\t\treport.resource_arn = arn\n\t\t\t\t\treport.resource_tags = bucket.tags\n\t\t\t\t\treport.status = 'PASS'\n\t\t\t\t\treport.status_extended = f'S3 Bucket {bucket.name} is not public.'\n\t\t\t\t\tif not (\n\t\t\t\t\t\tbucket.public_access_block.ignore_public_acls\n\t\t\t\t\t\tand bucket.public_access_block.restrict_public_buckets\n\t\t\t\t\t):\n\t\t\t\t\t\t# 3. If bucket has no public block, check bucket ACL\n\t\t\t\t\t\tfor grantee in bucket.acl_grantees:\n\t\t\t\t\t\t\tif grantee.type in 'Group':\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t'AllUsers' in grantee.URI\n\t\t\t\t\t\t\t\t\tor 'AuthenticatedUsers' in grantee.URI\n\t\t\t\t\t\t\t\t):\n\t\t\t\t\t\t\t\t\treport.status = 'FAIL'\n\t\t\t\t\t\t\t\t\treport.status_extended = f'S3 Bucket {bucket.name} has public access due to bucket ACL.'\n\n\t\t\t\t\t\t# 4. Check bucket policy\n\t\t\t\t\t\tif is_policy_public(bucket.policy, s3_client.audited_account):\n\t\t\t\t\t\t\treport.status = 'FAIL'\n\t\t\t\t\t\t\treport.status_extended = f'S3 Bucket {bucket.name} has public access due to bucket policy.'\n\t\t\t\t\tfindings.append(report)\n\t\treturn findings",
    },
    # Azure
    "how can I ensure that my Entra policy is secure?": {
        "security_analysis": "The requested prompt is related to cloud security, specifically with Azure because Entra is the Microsoft product for identity and access management. This is a common security best practice to ensure that the Entra policy is secure to avoid unauthorized access to the resources.\nTo do this check at least you must verify that the Security Defaults are enabled.",
        "prowler_provider": "azure",
        "service": "entra",
        "check_name": "entra_security_defaults_enabled",
        "check_metadata": r"{\n  'Provider': 'azure',\n  'CheckID': 'entra_security_defaults_enabled',\n  'CheckTitle': 'Ensure Security Defaults is enabled on Microsoft Entra ID',\n  'CheckType': [],\n  'ServiceName': 'entra',\n  'SubServiceName': '',\n  'ResourceIdTemplate': '',\n  'Severity': 'high',\n  'ResourceType': '#microsoft.graph.identitySecurityDefaultsEnforcementPolicy',\n  'Description': 'Security defaults in Microsoft Entra ID make it easier to be secure and help protect your organization. Security defaults contain preconfigured security settings for common attacks. Security defaults is available to everyone. The goal is to ensure that all organizations have a basic level of security enabled at no extra cost. You may turn on security defaults in the Azure portal.',\n  'Risk': 'Security defaults provide secure default settings that we manage on behalf of organizations to keep customers safe until they are ready to manage their own identity security settings. For example, doing the following: - Requiring all users and admins to register for MFA. - Challenging users with MFA - when necessary, based on factors such as location, device, role, and task. - Disabling authentication from legacy authentication clients, which cant do MFA.',\n  'RelatedUrl': '',\n  'Remediation': {\n\t'Code': {\n\t  'CLI': '',\n\t  'NativeIaC': '',\n\t  'Other': '',\n\t  'Terraform': ''\n\t},\n\t'Recommendation': {\n\t  'Text': '1. From Azure Home select the Portal Menu. 2. Browse to Microsoft Entra ID > Properties 3. Select Manage security defaults 4. Set the Enable security defaults to Enabled 5. Select Save',\n\t  'Url': ''\n\t}\n  },\n  'Categories': [],\n  'DependsOn': [],\n  'RelatedTo': [],\n  'Notes': 'This recommendation should be implemented initially and then may be overridden by other service/product specific CIS Benchmarks. Administrators should also be aware that certain configurations in Microsoft Entra ID may impact other Microsoft services such as Microsoft 365.'\n}",
        "base_case_scenarios": [
            "- Scenario 1: The policy is not enabled. It should return a finding with a FAIL as status.",
            "- Scenario 2: The policy is enabled. It should return a finding with a PASS as status.",
        ],
        "check_tests": "class Test_entra_security_defaults_enabled:\n\tdef test_entra_no_tenants(self):\n\t\tentra_client = mock.MagicMock\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=set_mocked_azure_provider(),\n\t\t), mock.patch(\n\t\t\t'prowler.providers.azure.services.entra.entra_security_defaults_enabled.entra_security_defaults_enabled.entra_client',\n\t\t\tnew=entra_client,\n\t\t):\n\t\t\tfrom prowler.providers.azure.services.entra.entra_security_defaults_enabled.entra_security_defaults_enabled import (\n\t\t\t\tentra_security_defaults_enabled,\n\t\t\t)\n\n\t\t\tentra_client.security_default = {}\n\n\t\t\tcheck = entra_security_defaults_enabled()\n\t\t\tresult = check.execute()\n\t\t\tassert len(result) == 0\n\tdef test_entra_security_default_enabled(self):\n\t\tentra_client = mock.MagicMock\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=set_mocked_azure_provider(),\n\t\t), mock.patch(\n\t\t\t'prowler.providers.azure.services.entra.entra_security_defaults_enabled.entra_security_defaults_enabled.entra_client',\n\t\t\tnew=entra_client,\n\t\t):\n\t\t\tfrom prowler.providers.azure.services.entra.entra_security_defaults_enabled.entra_security_defaults_enabled import (\n\t\t\t\tentra_security_defaults_enabled,\n\t\t\t)\n\t\t\tfrom prowler.providers.azure.services.entra.entra_service import (\n\t\t\t\tSecurityDefault,\n\t\t\t)\n\n\t\t\tid = str(uuid4())\n\n\t\t\tentra_client.security_default = {\n\t\t\t\tDOMAIN: SecurityDefault(id=id, name='Sec Default', is_enabled=True)\n\t\t\t}\n\n\t\t\tcheck = entra_security_defaults_enabled()\n\t\t\tresult = check.execute()\n\t\t\tassert len(result) == 1\n\t\t\tassert result[0].status == 'PASS'\n\t\t\tassert result[0].status_extended == 'Entra security defaults is enabled.'\n\t\t\tassert result[0].subscription == f'Tenant: {DOMAIN}'\n\t\t\tassert result[0].resource_name == 'Sec Default'\n\t\t\tassert result[0].resource_id == id\n\n\tdef test_entra_security_default_disabled(self):\n\t\tentra_client = mock.MagicMock\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=set_mocked_azure_provider(),\n\t\t), mock.patch(\n\t\t\t'prowler.providers.azure.services.entra.entra_security_defaults_enabled.entra_security_defaults_enabled.entra_client',\n\t\t\tnew=entra_client,\n\t\t):\n\t\t\tfrom prowler.providers.azure.services.entra.entra_security_defaults_enabled.entra_security_defaults_enabled import (\n\t\t\t\tentra_security_defaults_enabled,\n\t\t\t)\n\t\t\tfrom prowler.providers.azure.services.entra.entra_service import (\n\t\t\t\tSecurityDefault,\n\t\t\t)\n\n\t\t\tid = str(uuid4())\n\n\t\t\tentra_client.security_default = {\n\t\t\t\tDOMAIN: SecurityDefault(id=id, name='Sec Default', is_enabled=False)\n\t\t\t}\n\n\t\t\tcheck = entra_security_defaults_enabled()\n\t\t\tresult = check.execute()\n\t\t\tassert len(result) == 1\n\t\t\tassert result[0].status == 'FAIL'\n\t\t\tassert result[0].status_extended == 'Entra security defaults is diabled.'\n\t\t\tassert result[0].subscription == f'Tenant: {DOMAIN}'\n\t\t\tassert result[0].resource_name == 'Sec Default'\n\t\t\tassert result[0].resource_id == id",
        "check_code": "from prowler.lib.check.models import Check, Check_Report_Azure\nfrom prowler.providers.azure.services.entra.entra_client import entra_client\n\n\nclass entra_security_defaults_enabled(Check):\n\tdef execute(self) -> Check_Report_Azure:\n\t\tfindings = []\n\n\t\tfor (\n\t\t\ttenant,\n\t\t\tsecurity_default,\n\t\t) in entra_client.security_default.items():\n\t\t\treport = Check_Report_Azure(self.metadata())\n\t\t\treport.status = 'FAIL'\n\t\t\treport.subscription = f'Tenant: {tenant}'\n\t\t\treport.resource_name = getattr(security_default, 'name', 'Security Default')\n\t\t\treport.resource_id = getattr(security_default, 'id', 'Security Default')\n\t\t\treport.status_extended = 'Entra security defaults is diabled.'\n\n\t\t\tif getattr(security_default, 'is_enabled', False):\n\t\t\t\treport.status = 'PASS'\n\t\t\t\treport.status_extended = 'Entra security defaults is enabled.'\n\n\t\t\tfindings.append(report)\n\n\t\treturn findings",
    },
    # GCP
    "create a check to ensure BigQuery datasets are encrypted with Customer-Managed Keys (CMKs).": {
        "security_analysis": "The requested prompt is related to cloud security, specifically with GCP because BigQuery is a GCP product for data analysis. This is a common security best practice to ensure that the BigQuery datasets are encrypted with Customer-Managed Keys (CMKs) to avoid unauthorized access to the data.\nTo do this check you must verify that the BigQuery datasets are encrypted with Customer-Managed Keys (CMKs).",
        "prowler_provider": "gcp",
        "service": "bigquery",
        "check_name": "bigquery_dataset_cmk_encryption",
        "check_metadata": r"{\n  'Provider': 'gcp',\n  'CheckID': 'bigquery_dataset_cmk_encryption',\n  'CheckTitle': 'Ensure BigQuery datasets are encrypted with Customer-Managed Keys (CMKs).',\n  'CheckType': [],\n  'ServiceName': 'bigquery',\n  'SubServiceName': '',\n  'ResourceIdTemplate': '',\n  'Severity': 'high',\n  'ResourceType': 'Dataset',\n  'Description': 'Ensure BigQuery datasets are encrypted with Customer-Managed Keys (CMKs) in order to have a more granular control over data encryption/decryption process.',\n  'Risk': 'If you want to have greater control, Customer-managed encryption keys (CMEK) can be used as encryption key management solution for BigQuery Data Sets.',\n  'RelatedUrl': '',\n  'Remediation': {\n\t'Code': {\n\t  'CLI': ''\n\t}\n  },\n  'Categories': [\n\t'encryption'\n  ],\n  'DependsOn': [],\n  'RelatedTo': [],\n  'Notes': ''\n}",
        "base_case_scenarios": [
            "- Scenario 1: There is no BigQuery Dataset in the audited project. It should not return findings.",
            "- Scenario 2: The dataset is not encrypted. It should return a finding with a FAIL as status.",
            "- Scenario 3: The dataset is encrypted. It should return a finding with a PASS as status.",
        ],
        "check_tests": "from unittest import mock\n\nfrom tests.providers.gcp.gcp_fixtures import GCP_PROJECT_ID, set_mocked_gcp_provider\n\n\nclass Test_bigquery_dataset_cmk_encryption:\n\tdef test_bigquery_no_datasets(self):\n\t\tbigquery_client = mock.MagicMock\n\t\tbigquery_client.datasets = []\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=set_mocked_gcp_provider(),\n\t\t), mock.patch(\n\t\t\t'prowler.providers.gcp.services.bigquery.bigquery_dataset_cmk_encryption.bigquery_dataset_cmk_encryption.bigquery_client',\n\t\t\tnew=bigquery_client,\n\t\t):\n\t\t\tfrom prowler.providers.gcp.services.bigquery.bigquery_dataset_cmk_encryption.bigquery_dataset_cmk_encryption import (\n\t\t\t\tbigquery_dataset_cmk_encryption,\n\t\t\t)\n\n\t\t\tcheck = bigquery_dataset_cmk_encryption()\n\t\t\tresult = check.execute()\n\t\t\tassert len(result) == 0\n\n\tdef test_one_compliant_dataset(self):\n\t\tbigquery_client = mock.MagicMock\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=set_mocked_gcp_provider(),\n\t\t), mock.patch(\n\t\t\t'prowler.providers.gcp.services.bigquery.bigquery_dataset_cmk_encryption.bigquery_dataset_cmk_encryption.bigquery_client',\n\t\t\tnew=bigquery_client,\n\t\t):\n\t\t\tfrom prowler.providers.gcp.services.bigquery.bigquery_dataset_cmk_encryption.bigquery_dataset_cmk_encryption import (\n\t\t\t\tbigquery_dataset_cmk_encryption,\n\t\t\t)\n\t\t\tfrom prowler.providers.gcp.services.bigquery.bigquery_service import Dataset\n\n\t\t\tdataset = Dataset(\n\t\t\t\tname='test',\n\t\t\t\tid='1234567890',\n\t\t\t\tregion='us-central1',\n\t\t\t\tcmk_encryption=True,\n\t\t\t\tpublic=False,\n\t\t\t\tproject_id=GCP_PROJECT_ID,\n\t\t\t)\n\t\t\tbigquery_client.project_ids = [GCP_PROJECT_ID]\n\t\t\tbigquery_client.datasets = [dataset]\n\n\t\t\tcheck = bigquery_dataset_cmk_encryption()\n\t\t\tresult = check.execute()\n\n\t\t\tassert len(result) == 1\n\t\t\tassert result[0].status == 'PASS'\n\t\t\tassert (\n\t\t\t\tresult[0].status_extended\n\t\t\t\t== f'Dataset {dataset.name} is encrypted with Customer-Managed Keys (CMKs).'\n\t\t\t)\n\t\t\tassert result[0].resource_id == dataset.id\n\t\t\tassert result[0].resource_name == dataset.name\n\t\t\tassert result[0].project_id == dataset.project_id\n\t\t\tassert result[0].location == dataset.region\n\n\tdef test_one_non_compliant_dataset(self):\n\t\tbigquery_client = mock.MagicMock\n\n\t\twith mock.patch(\n\t\t\t'prowler.providers.common.provider.Provider.get_global_provider',\n\t\t\treturn_value=set_mocked_gcp_provider(),\n\t\t), mock.patch(\n\t\t\t'prowler.providers.gcp.services.bigquery.bigquery_dataset_cmk_encryption.bigquery_dataset_cmk_encryption.bigquery_client',\n\t\t\tnew=bigquery_client,\n\t\t):\n\t\t\tfrom prowler.providers.gcp.services.bigquery.bigquery_dataset_cmk_encryption.bigquery_dataset_cmk_encryption import (\n\t\t\t\tbigquery_dataset_cmk_encryption,\n\t\t\t)\n\t\t\tfrom prowler.providers.gcp.services.bigquery.bigquery_service import Dataset\n\n\t\t\tdataset = Dataset(\n\t\t\t\tname='test',\n\t\t\t\tid='1234567890',\n\t\t\t\tregion='us-central1',\n\t\t\t\tcmk_encryption=False,\n\t\t\t\tpublic=False,\n\t\t\t\tproject_id=GCP_PROJECT_ID,\n\t\t\t)\n\n\t\t\tbigquery_client.project_ids = [GCP_PROJECT_ID]\n\t\t\tbigquery_client.datasets = [dataset]\n\n\t\t\tcheck = bigquery_dataset_cmk_encryption()\n\t\t\tresult = check.execute()\n\n\t\t\tassert len(result) == 1\n\t\t\tassert result[0].status == 'FAIL'\n\t\t\tassert (\n\t\t\t\tresult[0].status_extended\n\t\t\t\t== f'Dataset {dataset.name} is not encrypted with Customer-Managed Keys (CMKs).'\n\t\t\t)\n\t\t\tassert result[0].resource_id == dataset.id\n\t\t\tassert result[0].resource_name == dataset.name\n\t\t\tassert result[0].project_id == dataset.project_id\n\t\t\tassert result[0].location == dataset.region",
        "check_code": "from prowler.lib.check.models import Check, Check_Report_GCP\nfrom prowler.providers.gcp.services.bigquery.bigquery_client import bigquery_client\n\n\nclass bigquery_dataset_cmk_encryption(Check):\n\tdef execute(self) -> Check_Report_GCP:\n\t\tfindings = []\n\t\tfor dataset in bigquery_client.datasets:\n\t\t\treport = Check_Report_GCP(self.metadata())\n\t\t\treport.project_id = dataset.project_id\n\t\t\treport.resource_id = dataset.id\n\t\t\treport.resource_name = dataset.name\n\t\t\treport.location = dataset.region\n\t\t\treport.status = 'PASS'\n\t\t\treport.status_extended = f'Dataset {dataset.name} is encrypted with Customer-Managed Keys (CMKs).'\n\t\t\tif not dataset.cmk_encryption:\n\t\t\t\treport.status = 'FAIL'\n\t\t\t\treport.status_extended = f'Dataset {dataset.name} is not encrypted with Customer-Managed Keys (CMKs).'\n\t\t\tfindings.append(report)\n\n\t\treturn findings",
    },
    # Kubernetes
    "create a check to ensure that in my k8s cluster the secrets are not stored in the environment variables.": {
        "security_analysis": "The requested prompt is related to cloud security, specifically with Kubernetes because k8s is the short name for Kubernetes. This is a common security best practice to avoid storing secrets in the environment variables to avoid unauthorized access to the secrets.\nTo do this check you must verify that the secrets are not stored in the environment variables, instead the best practice is mounting secrets as files for enhanced security.",
        "prowler_provider": "kubernetes",
        "service": "core",
        "check_name": "core_no_secrets_envs",
        "check_metadata": r"{\n  'Provider': 'kubernetes',\n  'CheckID': 'core_no_secrets_envs',\n  'CheckTitle': 'Prefer using secrets as files over secrets as environment variables',\n  'CheckType': [],\n  'ServiceName': 'core',\n  'SubServiceName': '',\n  'ResourceIdTemplate': '',\n  'Severity': 'medium',\n  'ResourceType': 'KubernetesSecrets',\n  'Description': 'This check ensures that secrets in Kubernetes are used as files rather than environment variables. Using secrets as files is safer, as it reduces the risk of exposing sensitive data through application logs.',\n  'Risk': 'Secrets exposed as environment variables can be inadvertently logged by applications, leading to potential security breaches.',\n  'RelatedUrl': '',\n  'Remediation': {\n\t'Code': {\n\t  'CLI': '',\n\t  'NativeIaC': '',\n\t  'Other': '',\n\t  'Terraform': ''\n\t},\n\t'Recommendation': {\n\t  'Text': 'Minimize the use of environment variable secrets and prefer mounting secrets as files for enhanced security.',\n\t  'Url': ''\n\t}\n  },\n  'Categories': [\n\t'trustboundaries'\n  ],\n  'DependsOn': [],\n  'RelatedTo': [],\n  'Notes': 'Mounting secrets as files allows for dynamic updates of secrets without needing to restart the pod.'\n}",
        "base_case_scenarios": [
            "- Scenario 1: There are no enviroment variables in the k8s cluster. It should return a finding with a PASS as status.",
            "- Scenario 2: The secrets are stored in the environment variables. It should return a finding with a FAIL as status.",
            "- Scenario 3: The secrets are stored in the environment variables. It should return a finding with a FAIL as status.",
        ],
        "check_tests": "For now, there are no tests for kubernetes provider.",
        "check_code": "from prowler.lib.check.models import Check, Check_Report_Kubernetes\nfrom prowler.providers.kubernetes.services.core.core_client import core_client\n\n\nclass core_no_secrets_envs(Check):\n\tdef execute(self) -> Check_Report_Kubernetes:\n\t\tfindings = []\n\t\tfor pod in core_client.pods.values():\n\t\t\treport = Check_Report_Kubernetes(self.metadata())\n\t\t\treport.namespace = pod.namespace\n\t\t\treport.resource_name = pod.name\n\t\t\treport.resource_id = pod.uid\n\t\t\treport.status = 'PASS'\n\t\t\treport.status_extended = (\n\t\t\t\tf'Pod {pod.name} does not contain any secret environment variables.'\n\t\t\t)\n\n\t\t\tfor container in pod.containers.values():\n\t\t\t\tif 'secretKeyRef' in str(container.env):\n\t\t\t\t\treport.status = 'FAIL'\n\t\t\t\t\treport.status_extended = f'Pod {pod.name} contains secret environment variables in container {container.name}.'\n\t\t\t\t\tbreak\n\n\t\t\tfindings.append(report)\n\n\t\treturn findings",
    },
}
